# Добавление данных

<Meta>
reading_time: 7
</Meta>

<Overview>
1. **db.Exec** — выполнение INSERT, UPDATE, DELETE
2. **FormValue** — получение данных из формы
3. **Плейсхолдеры** — защита от SQL инъекций
4. **Result.LastInsertId** — ID добавленной записи
5. **Redirect** — перенаправление после добавления
</Overview>

<Theory>
### Паттерн: форма → обработчик → редирект

1. **GET** — показать пустую форму
2. **POST** — обработать данные, сохранить в БД
3. **Redirect** — перенаправить на список (PRG паттерн)

```go
func createHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method == http.MethodGet {
        // Показать форму
        tmpl.Execute(w, nil)
        return
    }
    
    // POST — обработка формы
    name := r.FormValue("name")
    price := r.FormValue("price")
    
    _, err := db.Exec(
        "INSERT INTO products (name, price) VALUES (?, ?)",
        name, price,
    )
    if err != nil {
        http.Error(w, err.Error(), 500)
        return
    }
    
    // Редирект на список
    http.Redirect(w, r, "/products", http.StatusSeeOther)
}
```

### Получение ID новой записи

```go
result, _ := db.Exec("INSERT INTO products (name) VALUES (?)", name)
id, _ := result.LastInsertId()
fmt.Println("Новый ID:", id)
```

### Валидация перед сохранением

```go
func createHandler(w http.ResponseWriter, r *http.Request) {
    name := strings.TrimSpace(r.FormValue("name"))
    priceStr := r.FormValue("price")
    
    // Валидация
    if name == "" {
        http.Error(w, "Имя обязательно", http.StatusBadRequest)
        return
    }
    
    price, err := strconv.ParseFloat(priceStr, 64)
    if err != nil || price < 0 {
        http.Error(w, "Некорректная цена", http.StatusBadRequest)
        return
    }
    
    // Сохранение
    db.Exec("INSERT INTO products (name, price) VALUES (?, ?)", name, price)
    http.Redirect(w, r, "/products", http.StatusSeeOther)
}
```

### PRG (Post/Redirect/Get) паттерн

**Без редиректа:**
- Пользователь нажимает F5 → повторная отправка формы
- Дубликаты в БД!

**С редиректом:**
- POST → сохранение → Redirect (303) → GET список
- F5 обновляет только список

```go
http.Redirect(w, r, "/products", http.StatusSeeOther)  // 303
```

### Транзакции при сложных вставках

```go
tx, _ := db.Begin()
defer tx.Rollback()

result, _ := tx.Exec("INSERT INTO orders (user_id) VALUES (?)", userID)
orderID, _ := result.LastInsertId()

for _, item := range items {
    tx.Exec("INSERT INTO order_items (order_id, product_id) VALUES (?, ?)",
        orderID, item.ProductID)
}

tx.Commit()
```
</Theory>

<Syntax>
### Добавление записи

```go
result, err := db.Exec("INSERT INTO table (col1, col2) VALUES (?, ?)", val1, val2)

// Получение ID новой записи
id, err := result.LastInsertId()

// Количество затронутых строк
affected, err := result.RowsAffected()
```

### Получение данных формы

```go
name := r.FormValue("name")
price := r.FormValue("price")
```
</Syntax>

<Examples>
кода

### Форма добавления (HTML)

**templates/create.html:**
```html
<!DOCTYPE html>
<html>
<head>
    <title>Add Product</title>
    <style>
        form { max-width: 400px; }
        label { display: block; margin-top: 10px; }
        input { width: 100%; padding: 8px; margin-top: 5px; }
        button { margin-top: 15px; padding: 10px 20px; }
        .error { color: red; }
    </style>
</head>
<body>
    <h1>Add New Product</h1>
    
    {{ if .Error }}
    <p class="error">{{ .Error }}</p>
    {{ end }}
    
    <form action="/create" method="POST">
        <label>Name:
            <input type="text" name="name" required>
        </label>
        
        <label>Price:
            <input type="number" name="price" required min="0">
        </label>
        
        <button type="submit">Add Product</button>
    </form>
    
    <p><a href="/">Back to list</a></p>
</body>
</html>
```

### Обработчик добавления

```go
package main

import (
    "database/sql"
    "html/template"
    "net/http"
    "strconv"
    
    "github.com/gorilla/mux"
    _ "github.com/go-sql-driver/mysql"
)

type Product struct {
    ID    int
    Name  string
    Price int
}

var database *sql.DB

func main() {
    var err error
    database, err = sql.Open("mysql", "root:password@tcp(localhost:3306)/productdb")
    if err != nil {
        panic(err)
    }
    defer database.Close()
    
    router := mux.NewRouter()
    router.HandleFunc("/", listHandler).Methods("GET")
    router.HandleFunc("/create", createHandler).Methods("GET", "POST")
    
    http.ListenAndServe(":8080", router)
}

func createHandler(w http.ResponseWriter, r *http.Request) {
    // GET — показать форму
    if r.Method == http.MethodGet {
        tmpl := template.Must(template.ParseFiles("templates/create.html"))
        tmpl.Execute(w, nil)
        return
    }
    
    // POST — обработать форму
    name := r.FormValue("name")
    priceStr := r.FormValue("price")
    
    // Валидация
    if name == "" {
        showError(w, "Name is required")
        return
    }
    
    price, err := strconv.Atoi(priceStr)
    if err != nil || price < 0 {
        showError(w, "Invalid price")
        return
    }
    
    // Добавление в БД
    result, err := database.Exec(
        "INSERT INTO products (name, price) VALUES (?, ?)",
        name, price,
    )
    if err != nil {
        showError(w, "Database error: "+err.Error())
        return
    }
    
    // Получаем ID новой записи (опционально)
    id, _ := result.LastInsertId()
    _ = id  // можно использовать для редиректа на страницу товара
    
    // Перенаправляем на список
    http.Redirect(w, r, "/", http.StatusSeeOther)
}

func showError(w http.ResponseWriter, message string) {
    tmpl := template.Must(template.ParseFiles("templates/create.html"))
    tmpl.Execute(w, map[string]string{"Error": message})
}

func listHandler(w http.ResponseWriter, r *http.Request) {
    rows, _ := database.Query("SELECT id, name, price FROM products")
    defer rows.Close()
    
    var products []Product
    for rows.Next() {
        var p Product
        rows.Scan(&p.ID, &p.Name, &p.Price)
        products = append(products, p)
    }
    
    tmpl := template.Must(template.ParseFiles("templates/list.html"))
    tmpl.Execute(w, products)
}
```

### Список с кнопкой добавления

**templates/list.html:**
```html
<!DOCTYPE html>
<html>
<head>
    <title>Products</title>
    <style>
        table { border-collapse: collapse; width: 100%; max-width: 600px; }
        th, td { border: 1px solid #ddd; padding: 8px; }
        th { background-color: #4CAF50; color: white; }
        .actions { margin-bottom: 20px; }
        .btn { padding: 10px 20px; background: #4CAF50; color: white; text-decoration: none; }
    </style>
</head>
<body>
    <h1>Products</h1>
    
    <div class="actions">
        <a href="/create" class="btn">+ Add Product</a>
    </div>
    
    <table>
        <tr>
            <th>ID</th>
            <th>Name</th>
            <th>Price</th>
        </tr>
        {{ range . }}
        <tr>
            <td>{{ .ID }}</td>
            <td>{{ .Name }}</td>
            <td>${{ .Price }}</td>
        </tr>
        {{ else }}
        <tr>
            <td colspan="3">No products yet</td>
        </tr>
        {{ end }}
    </table>
</body>
</html>
```

### Добавление с возвратом ID

```go
func createAndGetID(name string, price int) (int64, error) {
    result, err := database.Exec(
        "INSERT INTO products (name, price) VALUES (?, ?)",
        name, price,
    )
    if err != nil {
        return 0, err
    }
    
    return result.LastInsertId()
}

func createHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method == http.MethodPost {
        name := r.FormValue("name")
        price, _ := strconv.Atoi(r.FormValue("price"))
        
        id, err := createAndGetID(name, price)
        if err != nil {
            http.Error(w, err.Error(), 500)
            return
        }
        
        // Редирект на страницу нового товара
        http.Redirect(w, r, "/product/"+strconv.FormatInt(id, 10), http.StatusSeeOther)
        return
    }
    
    // GET — показать форму
    tmpl := template.Must(template.ParseFiles("templates/create.html"))
    tmpl.Execute(w, nil)
}
```

### Валидация данных

```go
type ProductForm struct {
    Name   string
    Price  int
    Errors map[string]string
}

func (f *ProductForm) Validate() bool {
    f.Errors = make(map[string]string)
    
    if strings.TrimSpace(f.Name) == "" {
        f.Errors["name"] = "Name is required"
    } else if len(f.Name) > 100 {
        f.Errors["name"] = "Name is too long (max 100 characters)"
    }
    
    if f.Price < 0 {
        f.Errors["price"] = "Price cannot be negative"
    } else if f.Price > 1000000 {
        f.Errors["price"] = "Price is too high"
    }
    
    return len(f.Errors) == 0
}

func createHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method == http.MethodPost {
        price, _ := strconv.Atoi(r.FormValue("price"))
        
        form := ProductForm{
            Name:  r.FormValue("name"),
            Price: price,
        }
        
        if !form.Validate() {
            tmpl := template.Must(template.ParseFiles("templates/create.html"))
            tmpl.Execute(w, form)
            return
        }
        
        database.Exec(
            "INSERT INTO products (name, price) VALUES (?, ?)",
            form.Name, form.Price,
        )
        
        http.Redirect(w, r, "/", http.StatusSeeOther)
        return
    }
    
    tmpl := template.Must(template.ParseFiles("templates/create.html"))
    tmpl.Execute(w, ProductForm{})
}
```

**templates/create.html с валидацией:**
```html
<!DOCTYPE html>
<html>
<head>
    <title>Add Product</title>
    <style>
        .error { color: red; font-size: 0.9em; }
        input.invalid { border-color: red; }
    </style>
</head>
<body>
    <h1>Add New Product</h1>
    
    <form action="/create" method="POST">
        <label>Name:
            <input type="text" name="name" value="{{ .Name }}"
                   {{ if .Errors.name }}class="invalid"{{ end }}>
            {{ if .Errors.name }}<span class="error">{{ .Errors.name }}</span>{{ end }}
        </label>
        
        <label>Price:
            <input type="number" name="price" value="{{ .Price }}"
                   {{ if .Errors.price }}class="invalid"{{ end }}>
            {{ if .Errors.price }}<span class="error">{{ .Errors.price }}</span>{{ end }}
        </label>
        
        <button type="submit">Add Product</button>
    </form>
</body>
</html>
```
</Examples>

<Pitfalls>
### 1. SQL инъекции

```go
// ❌ НИКОГДА так не делайте
query := "INSERT INTO products (name) VALUES ('" + name + "')"

// ✅ Используйте плейсхолдеры
database.Exec("INSERT INTO products (name) VALUES (?)", name)
```

### 2. Не проверяют ошибки

```go
// ❌ Игнорирование ошибки
database.Exec("INSERT INTO products (name, price) VALUES (?, ?)", name, price)

// ✅ Проверяйте ошибку
_, err := database.Exec("INSERT INTO products (name, price) VALUES (?, ?)", name, price)
if err != nil {
    // обработка ошибки
}
```

### 3. Двойная отправка формы

```go
// ❌ После POST остаёмся на той же странице
if r.Method == http.MethodPost {
    database.Exec(...)
    fmt.Fprint(w, "Added!")  // Refresh = дублирование
}

// ✅ Редирект после успешного добавления
if r.Method == http.MethodPost {
    database.Exec(...)
    http.Redirect(w, r, "/", http.StatusSeeOther)
}
```
</Pitfalls>

<Task id="lab" mode="manual" points="60">
<Title>Лаба: Добавление данных (INSERT + возврат ID + PRG)</Title>
<Prompt>
Продолжите мини‑приложение и доведите создание задачи до “нормального” состояния: запись в БД, возврат ID, корректный HTTP ответ и отсутствие дублей при refresh.\n\n### Требования\n\n1) **Repository.CreateTask**\n- Реализуйте метод создания задачи в БД\n- Возвращайте `id` созданной записи\n- Используйте `context.Context` и плейсхолдеры\n\n2) **HTTP API (JSON)**\n- `POST /api/v1/tasks`:\n  - 201\n  - в ответе возвращает созданную задачу с `id`\n  - валидирует вход (`title` обязателен)\n\n3) **HTML форма**\n- `POST /tasks` создаёт задачу и делает redirect на `/tasks/{id}` (PRG)\n\n4) **Ошибки**\n- Если пользователь прислал пустой `title` → 400 (API) / сообщение на форме (HTML)\n\n</Prompt>
<Criteria>
- Создание задачи работает и через API, и через HTML форму\n+- После refresh страницы результата (после редиректа) задача не дублируется\n+- В БД есть реальная запись (проверьте через `GET /api/v1/tasks` или sqlite клиент)\n+- Код не использует конкатенацию SQL строк с данными пользователя\n+</Criteria>
<Hints>
- Для SQLite:\n  - можно использовать `res, err := db.ExecContext(ctx, \"INSERT ...\", ...)` и `res.LastInsertId()`.\n- Для PRG используйте `http.StatusSeeOther`.\n- Самопроверка:\n  - `curl -i -X POST http://localhost:8080/api/v1/tasks -H \"Content-Type: application/json\" -d '{\"title\":\"write sql\"}'`\n  - `curl -i -X POST http://localhost:8080/api/v1/tasks -H \"Content-Type: application/json\" -d '{\"title\":\"\"}'`\n+</Hints>
</Task>
