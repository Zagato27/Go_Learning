# Статические файлы

<Meta>
reading_time: 5
</Meta>

<Overview>
1. **http.FileServer** — сервер статических файлов
2. **http.Dir** — указание директории с файлами
3. **http.ServeFile** — отдача одного файла
4. **StripPrefix** — удаление префикса из URL
5. **Кэширование** — заголовки для кэша браузера
</Overview>

<Theory>
### Зачем нужен FileServer?

Веб-приложениям нужно отдавать статические файлы:
- CSS стили
- JavaScript
- Изображения
- Шрифты

### Простейший файловый сервер

```go
// Папка ./static/ доступна по /static/
fs := http.FileServer(http.Dir("./static"))
http.Handle("/static/", http.StripPrefix("/static/", fs))
```

**StripPrefix** нужен чтобы убрать `/static/` из пути:
```
Запрос:  /static/css/style.css
Файл:    ./static/css/style.css (без StripPrefix)
         ./css/style.css        (с StripPrefix)
```

### Как работает http.Dir?

```go
http.Dir("./static")  // ограничивает доступ папкой ./static
```

⚠️ **Безопасность:** без `http.Dir` можно было бы читать любые файлы!

### Отдача одного файла

```go
func faviconHandler(w http.ResponseWriter, r *http.Request) {
    http.ServeFile(w, r, "./static/favicon.ico")
}
http.HandleFunc("/favicon.ico", faviconHandler)
```

### Кэширование статики

```go
func staticHandler(h http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Кэш на 1 год
        w.Header().Set("Cache-Control", "public, max-age=31536000")
        h.ServeHTTP(w, r)
    })
}

fs := http.FileServer(http.Dir("./static"))
http.Handle("/static/", staticHandler(http.StripPrefix("/static/", fs)))
```

### Встроенные файлы (embed)

Go 1.16+ позволяет встраивать файлы в бинарник:

```go
//go:embed static/*
var staticFS embed.FS

func main() {
    fs := http.FileServer(http.FS(staticFS))
    http.Handle("/static/", fs)
}
```

Теперь статика внутри исполняемого файла!

### Структура папок

```
myapp/
├── main.go
├── static/
│   ├── css/
│   │   └── style.css
│   ├── js/
│   │   └── app.js
│   └── images/
│       └── logo.png
└── templates/
    └── index.html
```
</Theory>

<Syntax>
### FileServer

```go
http.FileServer(root FileSystem) Handler
http.Dir(name string) Dir
```

### ServeFile

```go
http.ServeFile(w ResponseWriter, r *Request, name string)
```

### StripPrefix

```go
http.StripPrefix(prefix string, h Handler) Handler
```
</Syntax>

<Examples>
кода

### Простой файловый сервер

```go
package main

import (
    "fmt"
    "net/http"
)

func main() {
    // Отдаём файлы из папки "static"
    fs := http.FileServer(http.Dir("static"))
    
    http.Handle("/", fs)
    
    fmt.Println("Server started at :8080")
    http.ListenAndServe(":8080", nil)
}
```

### Статика с префиксом

```go
package main

import (
    "fmt"
    "net/http"
)

func main() {
    // URL: /static/style.css → файл: static/style.css
    fs := http.FileServer(http.Dir("static"))
    http.Handle("/static/", http.StripPrefix("/static/", fs))
    
    // Главная страница
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprint(w, `
<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="/static/style.css">
</head>
<body>
    <h1>Hello!</h1>
    <script src="/static/app.js"></script>
</body>
</html>
        `)
    })
    
    http.ListenAndServe(":8080", nil)
}
```

### Отдача одного файла

```go
package main

import (
    "fmt"
    "net/http"
)

func main() {
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        http.ServeFile(w, r, "public/index.html")
    })
    
    http.HandleFunc("/about", func(w http.ResponseWriter, r *http.Request) {
        http.ServeFile(w, r, "public/about.html")
    })
    
    http.HandleFunc("/favicon.ico", func(w http.ResponseWriter, r *http.Request) {
        http.ServeFile(w, r, "public/favicon.ico")
    })
    
    fmt.Println("Server started at :8080")
    http.ListenAndServe(":8080", nil)
}
```

### Комбинация статики и динамики

```go
package main

import (
    "encoding/json"
    "fmt"
    "net/http"
)

func main() {
    // Статические файлы
    fs := http.FileServer(http.Dir("static"))
    http.Handle("/static/", http.StripPrefix("/static/", fs))
    
    // Главная страница (статическая)
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        if r.URL.Path != "/" {
            http.NotFound(w, r)
            return
        }
        http.ServeFile(w, r, "static/index.html")
    })
    
    // API (динамическое)
    http.HandleFunc("/api/data", func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{
            "message": "Hello from API",
        })
    })
    
    fmt.Println("Server started at :8080")
    http.ListenAndServe(":8080", nil)
}
```

### Кэширование статики

```go
package main

import (
    "net/http"
    "time"
)

func cacheMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Кэш на 1 час
        w.Header().Set("Cache-Control", "public, max-age=3600")
        w.Header().Set("Expires", time.Now().Add(time.Hour).Format(http.TimeFormat))
        next.ServeHTTP(w, r)
    })
}

func main() {
    fs := http.FileServer(http.Dir("static"))
    
    http.Handle("/static/", 
        http.StripPrefix("/static/", 
            cacheMiddleware(fs)))
    
    http.ListenAndServe(":8080", nil)
}
```

### Защита от directory listing

```go
package main

import (
    "net/http"
    "os"
    "path"
)

type neuteredFileSystem struct {
    fs http.FileSystem
}

func (nfs neuteredFileSystem) Open(p string) (http.File, error) {
    f, err := nfs.fs.Open(p)
    if err != nil {
        return nil, err
    }
    
    s, _ := f.Stat()
    if s.IsDir() {
        // Проверяем наличие index.html
        index := path.Join(p, "index.html")
        if _, err := nfs.fs.Open(index); err != nil {
            closeErr := f.Close()
            if closeErr != nil {
                return nil, closeErr
            }
            return nil, os.ErrNotExist
        }
    }
    
    return f, nil
}

func main() {
    fs := neuteredFileSystem{http.Dir("static")}
    
    http.Handle("/", http.FileServer(fs))
    
    http.ListenAndServe(":8080", nil)
}
```

### Загрузка файлов (скачивание)

```go
package main

import (
    "fmt"
    "net/http"
    "path/filepath"
)

func downloadHandler(w http.ResponseWriter, r *http.Request) {
    filename := r.URL.Query().Get("file")
    if filename == "" {
        http.Error(w, "File not specified", http.StatusBadRequest)
        return
    }
    
    // Безопасность: только имя файла без пути
    filename = filepath.Base(filename)
    filepath := filepath.Join("downloads", filename)
    
    // Заголовок для скачивания
    w.Header().Set("Content-Disposition", 
        fmt.Sprintf("attachment; filename=%s", filename))
    
    http.ServeFile(w, r, filepath)
}

func main() {
    http.HandleFunc("/download", downloadHandler)
    
    http.ListenAndServe(":8080", nil)
}
```

### SPA (Single Page Application) роутинг

```go
package main

import (
    "net/http"
    "os"
    "path/filepath"
)

func spaHandler(w http.ResponseWriter, r *http.Request) {
    // Проверяем существование файла
    path := filepath.Join("public", r.URL.Path)
    
    _, err := os.Stat(path)
    if os.IsNotExist(err) {
        // Файл не найден — отдаём index.html (для SPA роутинга)
        http.ServeFile(w, r, "public/index.html")
        return
    }
    
    // Файл существует — отдаём его
    http.ServeFile(w, r, path)
}

func main() {
    http.HandleFunc("/", spaHandler)
    
    http.ListenAndServe(":8080", nil)
}
```
</Examples>

<Pitfalls>
### 1. Неверный путь к папке

```go
// ❌ Относительный путь может не работать
http.FileServer(http.Dir("./static"))

// ✅ Проверьте текущую директорию
// или используйте абсолютный путь
```

### 2. Directory listing

```go
// ❌ По умолчанию показывает содержимое папки
http.FileServer(http.Dir("static"))

// ✅ Используйте neuteredFileSystem или
// добавьте index.html в каждую папку
```

### 3. StripPrefix забыт

```go
// ❌ URL /static/style.css → файл static/static/style.css
http.Handle("/static/", http.FileServer(http.Dir("static")))

// ✅ Используйте StripPrefix
http.Handle("/static/", 
    http.StripPrefix("/static/", 
        http.FileServer(http.Dir("static"))))
```
</Pitfalls>

<Task id="lab" mode="manual" points="60">
<Title>Лаба: Статические файлы (CSS/JS) + безопасная раздача</Title>
<Prompt>
Продолжите мини‑приложение и добавьте поддержку статики.

**Цель:** подключить CSS/JS на страницу, раздавать файлы через `/static/`, не показывать листинг директорий.

### Требования

1) **Статика**
- Создайте папку `static/` и минимум 2 файла:
  - `static/app.css`
  - `static/app.js`
- Подключите их на главной странице (`/`) (можно просто отдавать HTML строкой или через шаблоны).

2) **Раздача файлов**
- `GET /static/app.css` отдаёт CSS
- `GET /static/app.js` отдаёт JS
- Никакого `directory listing` для `/static/` (если открыть `/static/`, не должно быть списка файлов)

3) **Кэширование (минимум)**
- Для статики выставьте `Cache-Control` (например, `public, max-age=3600`).

</Prompt>
<Criteria>
- `/` возвращает HTML, где подключены `/static/app.css` и `/static/app.js`
- `curl -I http://localhost:8080/static/app.css` содержит корректный `Content-Type` и `Cache-Control`
- `GET /static/` не показывает список файлов (либо 404, либо редирект/заглушка)
</Criteria>
<Hints>
- Используйте `http.FileServer` + `http.StripPrefix("/static/", ...)`.
- Чтобы отключить листинг директорий, можно:
  - проверить `r.URL.Path` и не отдавать директорию без `index.html`, или
  - обернуть `http.FileSystem` и запретить `Readdir` (вариант “neutered FS”).
- Самопроверка:
  - `curl http://localhost:8080/`
  - `curl -I http://localhost:8080/static/app.css`
  - `curl -i http://localhost:8080/static/`
</Hints>
</Task>
