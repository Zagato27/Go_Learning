# Маршрутизация

<Meta>
reading_time: 5
</Meta>

<Overview>
1. **HandleFunc** — привязка функции к маршруту
2. **Handle** — привязка Handler интерфейса к маршруту
3. **Паттерны** — `/` (корень), `/about` (точный путь)
4. **Trailing slash** — `/api/` vs `/api`
5. **http.ServeMux** — стандартный маршрутизатор
</Overview>

<Theory>
### Что такое маршрутизация?

**Маршрутизация** — сопоставление URL-путей с обработчиками:

```
GET /users     → usersHandler
GET /about     → aboutHandler
GET /api/items → apiHandler
```

### Стандартный маршрутизатор (ServeMux)

```go
mux := http.NewServeMux()
mux.HandleFunc("/users", usersHandler)
mux.HandleFunc("/about", aboutHandler)

http.ListenAndServe(":8080", mux)
```

Или используйте глобальный:
```go
http.HandleFunc("/users", usersHandler)  // DefaultServeMux
http.ListenAndServe(":8080", nil)        // nil = DefaultServeMux
```

### Правила сопоставления

1. **Точное совпадение** приоритетнее
2. **Trailing slash** — `/api/` ловит всё под `/api/`
3. **Корень `/`** — ловит ВСЁ, что не совпало

```go
http.HandleFunc("/", rootHandler)         // /any, /path
http.HandleFunc("/users", usersHandler)   // только /users
http.HandleFunc("/api/", apiHandler)      // /api/, /api/users, /api/items
```

### Ограничения стандартного роутера

- ❌ Нет параметров в URL (`/users/{id}`)
- ❌ Нет фильтрации по HTTP-методу
- ❌ Нет middleware
- ❌ Нет регулярных выражений

Для этого используйте `gorilla/mux` или другие роутеры.

### Определение HTTP-метода вручную

```go
func handler(w http.ResponseWriter, r *http.Request) {
    switch r.Method {
    case http.MethodGet:
        // GET логика
    case http.MethodPost:
        // POST логика
    default:
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
    }
}
```

### Обработка 404

```go
func notFoundHandler(w http.ResponseWriter, r *http.Request) {
    http.Error(w, "Page not found", http.StatusNotFound)
}

// Корень "/" ловит все не найденные
http.HandleFunc("/", notFoundHandler)
```
</Theory>

<Syntax>
### HandleFunc

```go
http.HandleFunc(pattern string, handler func(ResponseWriter, *Request))
```

### Handle

```go
http.Handle(pattern string, handler Handler)
```

### Паттерны маршрутов

```go
"/"           // корень сайта (ловит все!)
"/about"     // точный путь /about
"/api/"      // /api/ и всё под ним (/api/users, /api/items)
"/static/"   // для статических файлов
```
</Syntax>

<Examples>
кода

### Базовая маршрутизация

```go
package main

import (
    "fmt"
    "net/http"
)

func main() {
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprint(w, "Home Page")
    })
    
    http.HandleFunc("/about", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprint(w, "About Page")
    })
    
    http.HandleFunc("/contact", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprint(w, "Contact Page")
    })
    
    fmt.Println("Server started at :8080")
    http.ListenAndServe(":8080", nil)
}
```

### Handle с Handler интерфейсом

```go
package main

import (
    "fmt"
    "net/http"
)

type PageHandler struct {
    Title   string
    Content string
}

func (h PageHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "<h1>%s</h1><p>%s</p>", h.Title, h.Content)
}

func main() {
    homePage := PageHandler{
        Title:   "Welcome",
        Content: "This is the home page",
    }
    
    aboutPage := PageHandler{
        Title:   "About Us",
        Content: "Learn more about our company",
    }
    
    http.Handle("/", homePage)
    http.Handle("/about", aboutPage)
    
    http.ListenAndServe(":8080", nil)
}
```

### Отправка HTML файлов

```go
package main

import (
    "fmt"
    "net/http"
)

func main() {
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        http.ServeFile(w, r, "index.html")
    })
    
    http.HandleFunc("/about", func(w http.ResponseWriter, r *http.Request) {
        http.ServeFile(w, r, "about.html")
    })
    
    http.HandleFunc("/contact", func(w http.ResponseWriter, r *http.Request) {
        http.ServeFile(w, r, "contact.html")
    })
    
    fmt.Println("Server started at :8080")
    http.ListenAndServe(":8080", nil)
}
```

### Разделение по HTTP методам

```go
package main

import (
    "fmt"
    "net/http"
)

func usersHandler(w http.ResponseWriter, r *http.Request) {
    switch r.Method {
    case http.MethodGet:
        fmt.Fprint(w, "GET: List all users")
    case http.MethodPost:
        fmt.Fprint(w, "POST: Create user")
    case http.MethodPut:
        fmt.Fprint(w, "PUT: Update user")
    case http.MethodDelete:
        fmt.Fprint(w, "DELETE: Delete user")
    default:
        w.WriteHeader(http.StatusMethodNotAllowed)
        fmt.Fprint(w, "Method not allowed")
    }
}

func main() {
    http.HandleFunc("/users", usersHandler)
    
    http.ListenAndServe(":8080", nil)
}
```

### Кастомный ServeMux

```go
package main

import (
    "fmt"
    "net/http"
)

func main() {
    mux := http.NewServeMux()
    
    mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprint(w, "Home")
    })
    
    mux.HandleFunc("/api/", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, "API endpoint: %s", r.URL.Path)
    })
    
    // Используем кастомный mux
    http.ListenAndServe(":8080", mux)
}
```

### Обработка 404

```go
package main

import (
    "fmt"
    "net/http"
)

func main() {
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        // "/" ловит все несуществующие пути
        if r.URL.Path != "/" {
            http.NotFound(w, r)
            return
        }
        fmt.Fprint(w, "Home Page")
    })
    
    http.HandleFunc("/about", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprint(w, "About Page")
    })
    
    http.ListenAndServe(":8080", nil)
}
```

### API с версионированием

```go
package main

import (
    "encoding/json"
    "net/http"
)

func main() {
    // API v1
    http.HandleFunc("/api/v1/users", func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{
            "version": "1",
            "data":    "users list v1",
        })
    })
    
    // API v2
    http.HandleFunc("/api/v2/users", func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
            "version": "2",
            "data":    []string{"user1", "user2"},
        })
    })
    
    http.ListenAndServe(":8080", nil)
}
```

### Middleware паттерн

```go
package main

import (
    "fmt"
    "log"
    "net/http"
    "time"
)

// Middleware для логирования
func loggingMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        next(w, r)
        log.Printf("%s %s %v", r.Method, r.URL.Path, time.Since(start))
    }
}

func homeHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprint(w, "Home Page")
}

func aboutHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprint(w, "About Page")
}

func main() {
    http.HandleFunc("/", loggingMiddleware(homeHandler))
    http.HandleFunc("/about", loggingMiddleware(aboutHandler))
    
    http.ListenAndServe(":8080", nil)
}
```
</Examples>

<Pitfalls>
### 1. "/" ловит все пути

```go
// ❌ "/" перехватывает /unknown
http.HandleFunc("/", homeHandler)
// Путь /unknown попадёт в homeHandler!

// ✅ Проверяйте путь
if r.URL.Path != "/" {
    http.NotFound(w, r)
    return
}
```

### 2. Trailing slash имеет значение

```go
// ❌ /api и /api/ — разные маршруты!
http.HandleFunc("/api", apiHandler)
// Путь /api/users НЕ попадёт сюда

// ✅ Используйте /api/ для подпутей
http.HandleFunc("/api/", apiHandler)
// /api/users попадёт сюда
```

### 3. Порядок регистрации

```go
// Стандартный mux выбирает самый специфичный маршрут
// Порядок регистрации не важен

http.HandleFunc("/", home)
http.HandleFunc("/about", about)
// /about попадёт в about, не в home
```
</Pitfalls>

<Task id="lab" mode="manual" points="60">
<Title>Лаба: Маршрутизация (REST + параметры + группы)</Title>
<Prompt>
Продолжите мини‑приложение из предыдущей лабы и добавьте нормальную маршрутизацию для небольшого REST API.

**Где делать:** в том же проекте (например, `web-labs/01-first-app/`).  
**Стек:** `net/http` + Chi.

### Требования

1) **Группы и версия API**
- Сделайте группу `/api/v1`

2) **Ресурс Tasks**
Реализуйте эндпоинты:
- `GET /api/v1/tasks?limit=&offset=&q=` — список задач (пока можно хранить в памяти)
- `GET /api/v1/tasks/{id}` — одна задача
- `POST /api/v1/tasks` — создание задачи (JSON)

Формат ответа (пример):

```json
{ "id": 1, "title": "buy milk", "done": false }
```

3) **Коды ошибок**
- 400 на некорректный JSON/параметры
- 404 если `id` не найден
- 201 на успешное создание

4) **NotFound**
- Настройте общий `NotFound` handler (чтобы для неизвестных путей был понятный ответ).

</Prompt>
<Criteria>
- `GET /api/v1/tasks` возвращает JSON массив
- `POST /api/v1/tasks` принимает JSON и возвращает созданную сущность (201)
- `GET /api/v1/tasks/{id}` возвращает 200/404
- Валидация query параметров: `limit/offset` не отрицательные, есть разумные default
- Ошибки возвращаются единообразно (JSON с полями `error`/`message` или подобным)
</Criteria>
<Hints>
- Для `id` используйте `chi.URLParam(r, "id")` + `strconv.Atoi`.
- Для JSON: `json.NewDecoder(r.Body).Decode(&dto)` и не забыть `DisallowUnknownFields()` (опционально).
- Самопроверка (пример):
  - `curl -s http://localhost:8080/api/v1/tasks`
  - `curl -s -X POST http://localhost:8080/api/v1/tasks -H \"Content-Type: application/json\" -d '{\"title\":\"buy milk\"}'`
  - `curl -s http://localhost:8080/api/v1/tasks/1`
</Hints>
</Task>
