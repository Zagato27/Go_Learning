# Структурное логирование: log/slog

<Meta>
reading_time: 10
</Meta>

<Overview>
1. **log/slog** — стандартная библиотека для структурных логов (Go 1.21+)
2. Структурные логи = сообщение + **ключи/значения** → легко искать и строить метрики
3. В веб‑сервисах обязательны: **request_id**, статус, метод, путь, latency
4. Старайтесь логировать **события**, а не “потоки текста”
5. Не логируйте PII/секреты и контролируйте кардинальность полей
</Overview>

<Theory>
### Почему структурные логи

Если вы пишете:

```text
user 123 failed to create order 999 because timeout
```

то для поиска/фильтрации вы вынуждены парсить строки.

Если вы пишете:

```json
{"msg":"create order failed","user_id":123,"order_id":999,"err":"timeout","request_id":"..."}
```

то:
- можно легко фильтровать по `user_id`, `order_id`, `request_id`
- можно строить алерты “ошибок стало больше”
- можно коррелировать с трейсами (trace_id/span_id)

### Базовые понятия slog

- **Logger**: `*slog.Logger`
- **Handler**: куда и в каком формате писать (Text/JSON)
- **Attrs**: постоянные поля (`service`, `version`) и поля конкретного события
- **Уровни**: Debug/Info/Warn/Error

### Что логировать в REST сервисе (минимальный набор)

- входящий запрос: `method`, `path`, `status`, `duration_ms`, `request_id`
- ошибки: `err`, `kind`, `component`
- бизнес‑события (важные): `order_created`, `payment_failed` и т.п.
</Theory>

<Syntax>
### Базовая настройка

```go
handler := slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
	Level: slog.LevelInfo,
})

logger := slog.New(handler).With(
	"service", "users",
	"env", "dev",
)
slog.SetDefault(logger)
```

### Логирование

```go
slog.Info("user created", "user_id", id)
slog.Error("db query failed", "err", err, "query", "SELECT ...")
```

### Логи с контекстом

```go
slog.InfoContext(ctx, "request finished", "status", 200)
```
</Syntax>

<Examples>
### Пример: request_id middleware (net/http)

```go
package main

import (
	"context"
	"crypto/rand"
	"encoding/hex"
	"log/slog"
	"net/http"
	"time"
)

type ctxKey string

const requestIDKey ctxKey = "request_id"

func newRequestID() string {
	var b [16]byte
	_, _ = rand.Read(b[:])
	return hex.EncodeToString(b[:])
}

func withRequestID(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		rid := r.Header.Get("X-Request-Id")
		if rid == "" {
			rid = newRequestID()
		}
		ctx := context.WithValue(r.Context(), requestIDKey, rid)
		w.Header().Set("X-Request-Id", rid)
		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

func accessLog(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()
		next.ServeHTTP(w, r)
		rid, _ := r.Context().Value(requestIDKey).(string)

		slog.Info("request",
			"method", r.Method,
			"path", r.URL.Path,
			"request_id", rid,
			"duration_ms", time.Since(start).Milliseconds(),
		)
	})
}
```

### Пример: добавляем trace_id/span_id в лог (концепт)

Когда подключите OpenTelemetry, можно вытаскивать идентификаторы так:

```go
sc := trace.SpanFromContext(ctx).SpanContext()
logger.Info("something happened",
	"trace_id", sc.TraceID().String(),
	"span_id", sc.SpanID().String(),
)
```
</Examples>

<Pitfalls>
1. **Слишком много логов**: увеличивает стоимость и усложняет анализ
2. **PII/секреты**: не логируйте пароли, токены, полные карточные данные, сырые payload’ы
3. **Высокая кардинальность**: не добавляйте поля вроде `user_email` в каждый лог (взрывает индекс)
4. **Отсутствие request_id**: без него тяжело собирать историю одного запроса
5. **Логи без контекста**: “ошибка” без `err` и без ключевых полей бесполезна
</Pitfalls>

<Links>
- `https://pkg.go.dev/log/slog`
- `https://go.dev/blog/slog`
</Links>

<Task id="lab" mode="manual" points="60">
<Title>Лаба: Structured logging (slog) + request_id + trace correlation</Title>
<Prompt>
Сделайте логирование в capstone‑сервисе “по‑взрослому”: структурно, с корреляцией и понятными полями.

### Требования

1) **JSON‑логер**
- Используйте `log/slog` (JSON handler)
- Добавьте базовые поля: `service`, `env`, `version` (если есть)\n- Уровень логирования задаётся ENV (например, `LOG_LEVEL=debug|info|warn|error`)

2) **Access log**
- Для каждого запроса логируйте:\n  - method/path (или rpc method)\n  - status code\n  - duration_ms\n  - request_id\n  - error (если был)\n
3) **request_id**
- Если заголовок `X-Request-Id` пришёл — используйте его\n- Иначе сгенерируйте и верните в ответе\n
4) **Корреляция с трейсами**
- После подключения OpenTelemetry добавьте в логи `trace_id` и `span_id`\n- Убедитесь, что по `trace_id` можно связать лог и трейс\n
</Prompt>
<Criteria>
- Логи в JSON, читаемые и пригодные для поиска\n- `request_id` стабильно проходит через весь запрос и возвращается клиенту\n- При включённом tracing в логах есть trace_id/span_id\n</Criteria>
<Hints>
- Для HTTP удобно хранить request_id/trace в `context.Context`.\n- Для gRPC используйте interceptors.\n- Самопроверка:\n  - сделайте запрос\n  - найдите в логах request_id\n  - (после OTel) найдите trace_id и откройте этот trace в Jaeger/Tempo\n</Hints>
</Task>

