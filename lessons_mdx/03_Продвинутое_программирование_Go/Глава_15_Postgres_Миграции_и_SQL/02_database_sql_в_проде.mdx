# database/sql в проде: пул, транзакции, EXPLAIN

<Meta>
reading_time: 12
</Meta>

<Overview>
1. `sql.DB` — это **пул соединений**, а не одно соединение
2. В проде обязательно настраивать пул: `SetMaxOpenConns/SetMaxIdleConns/...`
3. Используйте `QueryContext/ExecContext/BeginTx` и **таймауты** на запросы
4. Транзакции: `defer tx.Rollback()` + изоляция + атомарность бизнес‑операций
5. Медленные запросы лечатся через **EXPLAIN/индексы**, а не “магией Go”
</Overview>

<Theory>
### Почему настройки пула важны

Если `MaxOpenConns` слишком маленький — запросы будут стоять в очереди.  
Если слишком большой — вы “убьёте” Postgres количеством соединений.

Правильные настройки зависят от нагрузки и ресурсов, но базовые идеи:
- ограничить максимум (`SetMaxOpenConns`)
- держать небольшой idle пул (`SetMaxIdleConns`)
- выставить lifetimes, чтобы соединения периодически обновлялись

### Контекст и таймауты

SQL‑запросы должны иметь ограничение по времени. Обычно это:
- таймаут на handler/request (`context.WithTimeout`)
- контекст пробрасывается до репозитория

### EXPLAIN и индексы

Если запрос медленный:
- сначала `EXPLAIN (ANALYZE, BUFFERS)` (на тестовой базе!)
- смотрим seq scan, hash join, sort, количество строк
- добавляем/правим индексы и сам запрос

В большинстве “плохих” случаев проблема не в Go, а в SQL/индексах/данных.
</Theory>

<Syntax>
### Настройка пула

```go
db.SetMaxOpenConns(20)
db.SetMaxIdleConns(10)
db.SetConnMaxLifetime(30 * time.Minute)
db.SetConnMaxIdleTime(5 * time.Minute)
```

### Контекстные методы

```go
row := db.QueryRowContext(ctx, "SELECT ...", arg)
_, err := db.ExecContext(ctx, "UPDATE ...", arg)
tx, err := db.BeginTx(ctx, &sql.TxOptions{Isolation: sql.LevelReadCommitted})
```

### Шаблон транзакции

```go
tx, err := db.BeginTx(ctx, nil)
if err != nil { return err }
defer tx.Rollback()

// ... tx.ExecContext / tx.QueryRowContext ...

return tx.Commit()
```
</Syntax>

<Examples>
### Пример: репозиторий с контекстом и таймаутом

```go
func (r *Repo) GetUser(ctx context.Context, id int64) (*User, error) {
	ctx, cancel := context.WithTimeout(ctx, 2*time.Second)
	defer cancel()

	var u User
	err := r.db.QueryRowContext(ctx,
		"SELECT id, email, created_at FROM users WHERE id=$1",
		id,
	).Scan(&u.ID, &u.Email, &u.CreatedAt)

	if err == sql.ErrNoRows {
		return nil, ErrNotFound
	}
	if err != nil {
		return nil, fmt.Errorf("select user: %w", err)
	}
	return &u, nil
}
```

### Пример: перевод денег (атомарно)

```go
func (r *Repo) Transfer(ctx context.Context, from, to int64, amount int64) error {
	tx, err := r.db.BeginTx(ctx, &sql.TxOptions{Isolation: sql.LevelSerializable})
	if err != nil {
		return err
	}
	defer tx.Rollback()

	// 1) списать
	if _, err := tx.ExecContext(ctx,
		"UPDATE accounts SET balance = balance - $1 WHERE id=$2",
		amount, from,
	); err != nil {
		return err
	}

	// 2) зачислить
	if _, err := tx.ExecContext(ctx,
		"UPDATE accounts SET balance = balance + $1 WHERE id=$2",
		amount, to,
	); err != nil {
		return err
	}

	return tx.Commit()
}
```

### Пример: диагностируем медленный запрос

```sql
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM users WHERE email = 'user@example.com';
```
</Examples>

<Pitfalls>
1. **Не закрыли rows**: `defer rows.Close()` обязателен
2. **Не проверили rows.Err()**: ошибки итерации теряются
3. **Нет таймаута**: запросы висят, пул забивается, сервис деградирует
4. **N+1**: много запросов вместо одного (лечится JOIN/IN/батчами)
5. **Слишком много соединений**: Postgres начинает тратить ресурсы на контекст‑свитчи и memory
</Pitfalls>

<Links>
- `https://pkg.go.dev/database/sql`
- `https://www.postgresql.org/docs/current/using-explain.html`
</Links>

<Task id="lab" mode="manual" points="60">
<Title>Лаба: database/sql “как в проде” (пул, tx, EXPLAIN)</Title>
<Prompt>
Сделайте работу с Postgres более “производственной”: настройки пула, транзакции, и понимание планов запросов.

### Требования

1) **Пул соединений**
- Настройте `SetMaxOpenConns`, `SetMaxIdleConns`, `SetConnMaxLifetime`, `SetConnMaxIdleTime`\n- Добавьте наблюдаемость: логируйте `db.Stats()` (периодически или через debug endpoint)

2) **Транзакция**
- Выберите одну бизнес‑операцию (например, создание заказа + позиции + списание stock)\n- Сделайте её атомарной через `BeginTx` + `Commit/Rollback`\n- Все запросы выполняйте с `context.Context` и таймаутами

3) **EXPLAIN + индекс**
- Возьмите один “тяжёлый” SELECT (например, поиск продуктов по имени или список заказов пользователя)\n- Запустите `EXPLAIN (ANALYZE, BUFFERS)`\n- Добавьте индекс, который улучшает план, и покажите “до/после”

</Prompt>
<Criteria>
- Пул настроен и значения обоснованы\n- Бизнес‑операция атомарна (нет частичных записей)\n- Есть конкретный пример EXPLAIN до/после и применённый индекс\n</Criteria>
<Hints>
- Индексы часто нужны на: `(user_id, created_at)` для списков и на `lower(name)`/GIN trgm для поиска.\n- EXPLAIN лучше с реальными данными (хотя бы небольшим seed).\n</Hints>
</Task>

