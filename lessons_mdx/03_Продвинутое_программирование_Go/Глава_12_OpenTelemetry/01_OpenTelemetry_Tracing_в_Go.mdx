# OpenTelemetry Tracing в Go

<Meta>
reading_time: 12
</Meta>

<Overview>
1. **Traces** показывают путь запроса через систему (service → service → DB/HTTP)
2. **Span** — шаг внутри трейса: операция + время + атрибуты + ошибки
3. В Go всё держится на **context propagation**: без `ctx` трассировка ломается
4. OpenTelemetry обычно экспортирует данные через **OTLP** в Collector → Jaeger/Tempo
5. В проде важны: **sampling**, контроль кардинальности атрибутов и корректный shutdown
</Overview>

<Theory>
### Что такое trace/span

- **Trace**: “транзакция”/запрос пользователя сквозь систему
- **Span**: одна операция внутри trace (например, “HTTP GET /users”, “SQL SELECT users”, “call payment-service”)

Span содержит:
- время начала/конца, длительность
- атрибуты (key/value)
- статус (OK/ERROR) и ошибки
- связи родитель/потомок

### Зачем tracing в backend проектах

Tracing помогает:
- быстро найти, где пропадает время (API, DB, внешние вызовы)
- разбирать p99 проблемы (вместо “у всех медленно”)
- кореллировать события: metrics ↔ logs ↔ traces

### Важное правило

**Context должен проходить через все слои**: handler → service → repo → http/grpc/sql.
Если где-то вместо `ctx` вы используете `context.Background()`, вы “обрубаете” цепочку трейса.
</Theory>

<Syntax>
### Минимальные шаги подключения tracing

1) Инициализировать TracerProvider + Exporter (обычно OTLP)  
2) Установить глобальный провагатор (`TraceContext`)  
3) Инструментировать входящие/исходящие вызовы (HTTP/gRPC/DB)  
4) Добавить свои spans вокруг бизнес‑операций

### Полезные библиотеки (экосистема)

- `otelhttp` — net/http middleware и client transport
- `otelgrpc` — gRPC interceptors
- `otelgin` — middleware для Gin

### Ручной span (когда нужно добавить бизнес‑контекст)

```go
tr := otel.Tracer("myapp")
ctx, span := tr.Start(ctx, "CreateOrder")
defer span.End()

span.SetAttributes(attribute.String("order_id", id))
span.RecordError(err)
```
</Syntax>

<Examples>
### Пример: базовая инициализация OTLP exporter (концепт)

Ниже — типовая “болванка” для реального проекта. В учебных заданиях можно оставить это как ориентир.

```go
package telemetry

import (
	"context"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
	"go.opentelemetry.io/otel/propagation"
	"go.opentelemetry.io/otel/sdk/resource"
	sdktrace "go.opentelemetry.io/otel/sdk/trace"
	semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
)

func Init(ctx context.Context, serviceName string) (shutdown func(context.Context) error, err error) {
	exp, err := otlptracegrpc.New(ctx) // по умолчанию OTLP endpoint берётся из env
	if err != nil {
		return nil, err
	}

	res, err := resource.New(ctx,
		resource.WithAttributes(semconv.ServiceNameKey.String(serviceName)),
	)
	if err != nil {
		return nil, err
	}

	tp := sdktrace.NewTracerProvider(
		sdktrace.WithBatcher(exp),
		sdktrace.WithResource(res),
	)

	otel.SetTracerProvider(tp)
	otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
		propagation.TraceContext{},
		propagation.Baggage{},
	))

	return tp.Shutdown, nil
}
```

### Пример: docker-compose для local‑наблюдаемости (Collector + Jaeger)

```yaml
services:
  otel-collector:
    image: otel/opentelemetry-collector:latest
    ports:
      - "4317:4317"   # OTLP gRPC
      - "4318:4318"   # OTLP HTTP

  jaeger:
    image: jaegertracing/all-in-one:latest
    ports:
      - "16686:16686" # UI
```
</Examples>

<Pitfalls>
1. **Нет shutdown**: буферы не сбрасываются, трейсы теряются при остановке
2. **Слишком много атрибутов**: “взрывает” хранение и делает поиск дорогим
3. **Высокая кардинальность**: не добавляйте в атрибуты email/uuid на каждый запрос без необходимости
4. **Непроброшенный ctx**: один `context.Background()` ломает дерево span’ов
5. **Сэмплирование**: в проде почти всегда нужно (иначе будет слишком много данных)
</Pitfalls>

<Links>
- `https://opentelemetry.io/docs/`
- `https://opentelemetry.io/docs/languages/go/`
- `https://github.com/open-telemetry/opentelemetry-go`
</Links>

<Task id="lab" mode="manual" points="60">
<Title>Лаба: OpenTelemetry Tracing в capstone (init + spans + shutdown)</Title>
<Prompt>
Подключите OpenTelemetry tracing к вашему capstone‑сервису и добейтесь того, чтобы трейсы стабильно доходили до backend’а (Jaeger/Tempo).

### Требования

1) **Инициализация SDK**
- TracerProvider + OTLP exporter (grpc или http)
- Resource атрибуты: `service.name`, `service.version` (если есть), `deployment.environment`
- Сэмплирование (в dev можно AlwaysOn, но опишите варианты)

2) **Graceful shutdown**
- При завершении сервиса корректно вызывается `Shutdown(ctx)` у tracer provider/exporter\n- Трейсы не “теряются” при остановке

3) **Spans в ключевых местах**
- Минимум:
  - входящий запрос (HTTP или gRPC)
  - 1 usecase span (бизнес операция)
  - 1 DB span (SQL/ORM)
- Осмысленные имена span’ов и атрибуты (без высокой кардинальности)

4) **Локальная проверка**
- Поднимите Jaeger/Tempo + otel-collector (docker-compose)
- Убедитесь, что trace виден и содержит несколько span’ов

</Prompt>
<Criteria>
- Есть работающий локальный стенд (compose) и команда запуска
- В Jaeger/Tempo видно trace дерево (не один span)\n- В README описано, какие spans где создаются и какие атрибуты пишутся
</Criteria>
<Hints>
- Не кладите user_id/email/uuid в атрибуты каждого span’а без необходимости.\n- Главное правило: всегда протаскивайте `ctx`.\n</Hints>
</Task>

