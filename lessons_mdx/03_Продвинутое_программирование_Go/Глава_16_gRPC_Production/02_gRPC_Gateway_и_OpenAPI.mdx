# gRPC-Gateway и OpenAPI

<Meta>
reading_time: 10
</Meta>

<Overview>
1. Браузеры не умеют gRPC напрямую → нужен **grpc-gateway** (REST ↔ gRPC)
2. API описывается в `.proto`, а REST‑маппинг задаётся через **google.api.http**
3. Можно генерировать **OpenAPI/Swagger** из proto
4. Gateway полезен, когда хотите один контракт, но 2 вида клиентов (REST и gRPC)
5. Важно продумать: auth, error mapping, лимиты и совместимость
</Overview>

<Theory>
### Когда нужен grpc-gateway

Используйте, если:
- внутренние сервисы общаются по gRPC
- внешний/веб‑клиенту нужен REST/JSON
- хотите единый контракт (proto) и автогенерацию клиент/сервер

Не всегда нужен: если у вас только backend-to-backend и нет браузерных клиентов.

### Как это выглядит

```
Browser/REST client ──HTTP/JSON──> grpc-gateway ──gRPC──> gRPC service
```
</Theory>

<Syntax>
### Пример proto с HTTP аннотациями

```protobuf
syntax = "proto3";

package users.v1;

import "google/api/annotations.proto";

service UsersService {
  rpc GetUser(GetUserRequest) returns (GetUserResponse) {
    option (google.api.http) = {
      get: "/api/v1/users/{id}"
    };
  }
}

message GetUserRequest {
  int64 id = 1;
}
message GetUserResponse {
  User user = 1;
}
message User {
  int64 id = 1;
  string email = 2;
}
```

### Генерация (пример команд)

```bash
protoc \
  -I proto \
  -I third_party \
  --go_out=./gen --go_opt=paths=source_relative \
  --go-grpc_out=./gen --go-grpc_opt=paths=source_relative \
  --grpc-gateway_out=./gen --grpc-gateway_opt=paths=source_relative \
  proto/users/v1/users.proto
```

Для OpenAPI:

```bash
protoc \
  --openapiv2_out=./openapi \
  proto/users/v1/users.proto
```
</Syntax>

<Examples>
### Пример: запуск gateway (концепт)

```go
ctx := context.Background()

mux := runtime.NewServeMux()
opts := []grpc.DialOption{grpc.WithTransportCredentials(insecure.NewCredentials())}

_ = pb.RegisterUsersServiceHandlerFromEndpoint(ctx, mux, "localhost:9090", opts)

httpSrv := &http.Server{
	Addr:    ":8080",
	Handler: mux,
}
_ = httpSrv.ListenAndServe()
```

### Важный момент про ошибки

gRPC имеет коды `codes.*`, а REST обычно использует HTTP status codes.
Gateway умеет маппить ошибки, но вам нужно определиться со стандартом ошибок (body формат) и обеспечить единообразие.
</Examples>

<Pitfalls>
1. **Стриминг**: не все streaming‑паттерны удобно маппятся в REST
2. **Auth**: нужно прокидывать токены/метадату корректно
3. **Версионирование**: версионируйте и proto, и REST пути (`/api/v1/...`)
4. **Ошибки**: продумайте формат ошибок для REST клиентов
5. **Дублирование логики**: gateway должен быть “тонким”, логика — в gRPC сервисе
</Pitfalls>

<Links>
- `https://github.com/grpc-ecosystem/grpc-gateway`
- `https://github.com/googleapis/googleapis` (annotations)
</Links>

<Task id="lab" mode="manual" points="60">
<Title>Лаба: grpc-gateway + OpenAPI для gRPC capstone</Title>
<Prompt>
Сделайте REST “фасад” для части gRPC API через grpc-gateway и сгенерируйте OpenAPI спецификацию.

### Требования

1) **Gateway**
- Добавьте grpc-gateway для 1–2 RPC методов\n- REST путь должен быть версионирован (например, `/api/v1/users/...`)\n- Gateway не содержит бизнес‑логики: только проксирование в gRPC

2) **Annotations**
- Используйте google.api.http annotations в proto\n- Проверьте, что маппинг корректный (path params, query params)

3) **OpenAPI**
- Сгенерируйте OpenAPI (swagger.json/yaml)\n- Подключите Swagger UI или отдавайте файл + краткая инструкция, как открыть

4) **Ошибки**
- Определите, как gRPC ошибки маппятся в HTTP статусы (по умолчанию grpc-gateway уже делает маппинг, но важно проверить)\n- Документируйте формат ошибок для REST клиентов

</Prompt>
<Criteria>
- REST эндпоинт реально работает и проксирует в gRPC\n- OpenAPI генерируется воспроизводимо одной командой\n- В README есть “как проверить” (curl + ссылка на swagger)\n</Criteria>
<Hints>
- Удобно иметь `make generate` для proto/gateway/openapi.\n- Следите за версионированием и тем, чтобы не было дубля контрактов.\n</Hints>
</Task>

