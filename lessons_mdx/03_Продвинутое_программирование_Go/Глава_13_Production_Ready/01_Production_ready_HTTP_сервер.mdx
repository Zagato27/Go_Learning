# Production-ready HTTP сервер

<Meta>
reading_time: 11
</Meta>

<Overview>
1. Любой прод‑HTTP сервер в Go должен иметь **таймауты** (иначе slowloris/зависания)
2. Нужен **graceful shutdown** (SIGTERM) и корректное закрытие фоновых задач/соединений
3. Добавьте **health endpoints**: `/healthz` (liveness) и `/readyz` (readiness)
4. Важны **лимиты**: размер тела, количество соединений, время на заголовки
5. Весь сервис — про эксплуатацию: конфиг, логирование, метрики, трейсинг
</Overview>

<Theory>
### Почему таймауты обязательны

Без таймаутов:
- клиент может “подвесить” соединение, отправляя заголовки очень медленно
- запросы могут висеть бесконечно из‑за внешних зависимостей
- пул соединений забивается и сервис деградирует

Минимум, что нужно на сервере:
- `ReadHeaderTimeout` (защита от slowloris)
- `ReadTimeout`/`WriteTimeout` (в зависимости от типа API)
- `IdleTimeout` (keep-alive)

### Liveness vs Readiness

- **/healthz**: процесс жив? (обычно всегда 200, пока не “умираем”)
- **/readyz**: готовы обслуживать? (например, есть подключение к БД/очереди)

В Kubernetes readiness влияет на то, отправляют ли на pod трафик.

### Shutdown стратегия

При SIGTERM:
- прекращаем принимать новые соединения
- даём завершить текущие запросы (с таймаутом)
- останавливаем фоновые воркеры
- закрываем ресурсы (DB, tracer provider, etc.)
</Theory>

<Syntax>
### Базовый http.Server с таймаутами

```go
srv := &http.Server{
	Addr:              ":8080",
	Handler:           handler,
	ReadHeaderTimeout: 5 * time.Second,
	ReadTimeout:       15 * time.Second,
	WriteTimeout:      15 * time.Second,
	IdleTimeout:       60 * time.Second,
}
```

### Graceful shutdown (SIGINT/SIGTERM)

```go
ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
defer stop()

go srv.ListenAndServe()
<-ctx.Done()

shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
defer cancel()

_ = srv.Shutdown(shutdownCtx)
```

### Лимит размера тела запроса

```go
r.Body = http.MaxBytesReader(w, r.Body, 1<<20) // 1MB
```
</Syntax>

<Examples>
### Пример: каркас прод‑сервера (подходит и для Gin)

Gin работает поверх `net/http`, поэтому таймауты и shutdown настраиваются так же.

```go
package main

import (
	"context"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"
)

func main() {
	mux := http.NewServeMux()
	mux.HandleFunc("/healthz", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("ok"))
	})
	mux.HandleFunc("/readyz", func(w http.ResponseWriter, r *http.Request) {
		// TODO: проверка зависимостей (БД/очередь)
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("ready"))
	})

	srv := &http.Server{
		Addr:              ":8080",
		Handler:           mux,
		ReadHeaderTimeout: 5 * time.Second,
		ReadTimeout:       15 * time.Second,
		WriteTimeout:      15 * time.Second,
		IdleTimeout:       60 * time.Second,
	}

	ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
	defer stop()

	go func() {
		log.Println("server started on :8080")
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Println("server error:", err)
		}
	}()

	<-ctx.Done()
	log.Println("shutting down...")

	shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()
	_ = srv.Shutdown(shutdownCtx)
	log.Println("bye")
}
```
</Examples>

<Pitfalls>
1. **Нет ReadHeaderTimeout**: уязвимость к slowloris
2. **Бесконечные внешние вызовы**: без `context.WithTimeout` ваши handler’ы будут висеть
3. **Shutdown без таймаута**: можно зависнуть на остановке
4. **/readyz всегда 200**: readiness должен отражать реальную готовность
5. **pprof на основном порту**: держите debug endpoints отдельно и ограничивайте доступ
</Pitfalls>

<Links>
- `https://pkg.go.dev/net/http#Server`
- `https://pkg.go.dev/os/signal`
</Links>

<Task id="lab" mode="manual" points="60">
<Title>Лаба: Production‑ready HTTP сервер (timeouts, health/readiness, shutdown)</Title>
<Prompt>
Доведите HTTP слой capstone‑сервиса до production‑минимума.

### Требования

1) **Timeouts**
- Настройте timeouts у `http.Server`:\n  - `ReadHeaderTimeout`\n  - `ReadTimeout`\n  - `WriteTimeout`\n  - `IdleTimeout`\n- Обоснуйте значения в README (какие угрозы/проблемы закрываем)

2) **Лимиты**
- Ограничьте размер тела запроса (например, `MaxBytesReader` или лимит на уровне Gin)\n- (опционально) добавьте rate limiting или concurrency limit

3) **Health endpoints**
- `/healthz` (liveness) — ok, пока процесс жив\n- `/readyz` (readiness) — проверяет зависимости (БД/кэш/очереди)\n- При проблемах с зависимостями `/readyz` возвращает 503

4) **Graceful shutdown**
- При SIGINT/SIGTERM:\n  - перестать принимать новые запросы\n  - дождаться текущих в пределах таймаута\n  - закрыть ресурсы (DB/otel/exporter)

</Prompt>
<Criteria>
- `/healthz` и `/readyz` работают согласно описанию\n- При выключенной БД `/readyz` отдаёт 503\n- Таймауты действительно заданы и задокументированы\n- При остановке сервиса нет зависаний, shutdown корректный\n</Criteria>
<Hints>
- Для сигналов используйте `signal.NotifyContext`.\n- Для readiness проверки делайте `PingContext` с таймаутом.\n- Для Gin удобно запускать `http.Server` вручную, а не через `r.Run()`.\n</Hints>
</Task>

